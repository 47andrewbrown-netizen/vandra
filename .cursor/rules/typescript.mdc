---
description: TypeScript conventions and type safety rules for Vandra
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: true
---

# TypeScript Rules

## Strict Mode

TypeScript strict mode is enabled. All code must pass strict type checking:

```json
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitReturns": true
  }
}
```

## Type Declarations

### Prefer Interfaces for Object Shapes

```typescript
// Preferred: Interface for object types
interface User {
  id: string
  email: string
  name: string
}

// Use type for unions, intersections, and utilities
type AlertStatus = 'active' | 'paused' | 'expired'
type UserWithAlerts = User & { alerts: FlightAlert[] }
```

### Export Types Separately

```typescript
// types/flight.ts
export interface Flight {
  id: string
  origin: string
  destination: string
  price: number
  departureDate: Date
}

export type FlightSearchParams = {
  origin: string
  destination?: string
  maxPrice?: number
}
```

### Avoid `any`

Never use `any` without explicit justification:

```typescript
// BAD
function processData(data: any) { ... }

// GOOD - Use unknown and narrow
function processData(data: unknown) {
  if (isFlightData(data)) {
    // Now data is typed as FlightData
  }
}

// GOOD - If truly necessary, document why
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function legacyAdapter(data: any): NewFormat {
  // Required for compatibility with legacy flight API response
}
```

## Function Signatures

### Explicit Return Types for Public Functions

```typescript
// Public/exported functions: explicit return type
export function calculateDiscount(
  originalPrice: number,
  currentPrice: number
): number {
  return ((originalPrice - currentPrice) / originalPrice) * 100
}

// Internal/inline functions: inferred is OK
const flights = data.map((item) => ({
  id: item.id,
  price: item.price,
}))
```

### Use Function Overloads Sparingly

```typescript
// Prefer union types over overloads when possible
function formatPrice(amount: number, currency?: string): string

// Use overloads only when return type depends on input
function getAlert(id: string): Promise<FlightAlert>
function getAlert(id: string[]): Promise<FlightAlert[]>
function getAlert(id: string | string[]): Promise<FlightAlert | FlightAlert[]> {
  // implementation
}
```

## Null Handling

### Prefer Undefined Over Null

```typescript
// Preferred
interface SearchParams {
  destination?: string  // undefined when not provided
}

// Avoid (unless API requires null)
interface SearchParams {
  destination: string | null
}
```

### Non-Null Assertions

Avoid `!` assertions. Use proper type guards:

```typescript
// BAD
const user = getUser()!

// GOOD
const user = getUser()
if (!user) {
  throw new Error('User not found')
}
// user is now non-null
```

## Generics

### Meaningful Generic Names

```typescript
// BAD
function fetch<T>(url: string): Promise<T>

// GOOD
function fetch<TResponse>(url: string): Promise<TResponse>

// Common conventions:
// TData, TResponse, TError for data types
// TProps for component props
// TItem for array items
```

### Constrain Generics When Possible

```typescript
// Constrained generic
function getProperty<TObj extends object, TKey extends keyof TObj>(
  obj: TObj,
  key: TKey
): TObj[TKey] {
  return obj[key]
}
```

## Enums vs Union Types

### Prefer Union Types

```typescript
// BAD - Enums have runtime overhead
enum AlertStatus {
  Active = 'active',
  Paused = 'paused',
  Expired = 'expired',
}

// GOOD - Union type (no runtime cost)
type AlertStatus = 'active' | 'paused' | 'expired'

// GOOD - When you need runtime values, use const object
const ALERT_STATUS = {
  Active: 'active',
  Paused: 'paused',
  Expired: 'expired',
} as const

type AlertStatus = (typeof ALERT_STATUS)[keyof typeof ALERT_STATUS]
```

## Zod for Runtime Validation

Use Zod schemas for runtime validation and type inference:

```typescript
import { z } from 'zod'

// Define schema
const FlightAlertSchema = z.object({
  origin: z.string().length(3),
  destination: z.string().length(3).optional(),
  maxPrice: z.number().positive().optional(),
  departureDateRange: z.object({
    start: z.date(),
    end: z.date(),
  }).optional(),
})

// Infer TypeScript type from schema
type FlightAlert = z.infer<typeof FlightAlertSchema>

// Use for validation
function createAlert(input: unknown): FlightAlert {
  return FlightAlertSchema.parse(input)
}
```

## Async/Await

### Type Promise Returns

```typescript
// Explicit Promise return type
async function fetchFlights(params: SearchParams): Promise<Flight[]> {
  const response = await fetch('/api/flights', {
    method: 'POST',
    body: JSON.stringify(params),
  })
  
  if (!response.ok) {
    throw new Error('Failed to fetch flights')
  }
  
  return response.json() as Promise<Flight[]>
}
```

### Handle Promise.all Correctly

```typescript
// Type-safe Promise.all
const [flights, airports] = await Promise.all([
  fetchFlights(params),
  fetchAirports(),
] as const)
// flights: Flight[], airports: Airport[]
```

## Utility Types

Use built-in utility types appropriately:

```typescript
// Partial - all properties optional
type UpdateUserInput = Partial<User>

// Pick - select specific properties
type UserPreview = Pick<User, 'id' | 'name'>

// Omit - exclude properties
type CreateUserInput = Omit<User, 'id' | 'createdAt'>

// Required - make all properties required
type CompleteProfile = Required<UserProfile>

// Record - typed object
type AirportMap = Record<string, Airport>
```

## React Component Types

```typescript
// Function component with props
interface FlightCardProps {
  flight: Flight
  onSelect?: (flight: Flight) => void
  className?: string
}

export function FlightCard({ flight, onSelect, className }: FlightCardProps) {
  return (...)
}

// With children
interface LayoutProps {
  children: React.ReactNode
  title: string
}

// Event handlers
function handleClick(event: React.MouseEvent<HTMLButtonElement>) {
  // ...
}

function handleChange(event: React.ChangeEvent<HTMLInputElement>) {
  // ...
}
```
